# OAuth 2.0 第三方登录集成技术报告

## 1. 概述

本报告针对3D生成打印平台的用户系统需求,详细阐述OAuth 2.0第三方登录集成方案。基于项目现有技术栈(Vue3 + TypeScript + Pinia + Vite),提供完整的技术实现指南和最佳实践。

### 1.1 项目技术栈

- **前端框架**: Vue3 + TypeScript
- **构建工具**: Vite
- **状态管理**: Pinia 2.1+
- **路由管理**: Vue Router 4.2+
- **HTTP客户端**: Axios
- **UI框架**: Tailwind CSS

### 1.2 OAuth 2.0简介

OAuth 2.0是一个行业标准的授权协议,允许用户授权第三方应用访问其在某个服务提供商上存储的私密资源,而无需将用户名和密码提供给第三方应用。

**核心优势**:
- ✅ 用户无需记忆额外密码
- ✅ 提高注册转化率(减少注册步骤)
- ✅ 借助第三方平台的安全性
- ✅ 获取用户基本信息(头像、昵称、邮箱等)
- ✅ 改善用户体验

## 2. OAuth 2.0工作原理

### 2.1 授权码流程(Authorization Code Flow)

这是最安全且最常用的OAuth 2.0授权流程:

```
┌─────────┐                                           ┌────────────┐
│         │                                           │            │
│  用户   │                                           │  第三方    │
│ 浏览器  │                                           │ 认证平台   │
│         │                                           │ (GitHub)   │
└────┬────┘                                           └──────┬─────┘
     │                                                       │
     │  1. 点击"使用GitHub登录"                              │
     │────────────────────────────────────────────────────>│
     │                                                       │
     │  2. 重定向到GitHub授权页面                            │
     │<────────────────────────────────────────────────────│
     │                                                       │
     │  3. 用户授权                                          │
     │────────────────────────────────────────────────────>│
     │                                                       │
     │  4. 返回授权码(code)                                  │
     │<────────────────────────────────────────────────────│
     │                                                       │
┌────┴────┐                                           ┌──────┴─────┐
│         │                                           │            │
│ 后端    │  5. 使用code换取access_token               │  第三方    │
│ 服务器  │────────────────────────────────────────>│ 认证平台   │
│         │                                           │            │
│         │  6. 返回access_token                       │            │
│         │<────────────────────────────────────────│            │
│         │                                           │            │
│         │  7. 使用access_token获取用户信息            │            │
│         │────────────────────────────────────────>│            │
│         │                                           │            │
│         │  8. 返回用户信息                            │            │
│         │<────────────────────────────────────────│            │
└─────────┘                                           └────────────┘
     │                                                       
     │  9. 生成JWT令牌并返回前端                              
     │                                                       
```

### 2.2 关键术语

| 术语 | 说明 |
|-----|------|
| **Client ID** | 应用标识符,在OAuth提供商处注册应用时获得 |
| **Client Secret** | 应用密钥,必须保密,仅在后端使用 |
| **Authorization Code** | 临时授权码,用于换取access_token |
| **Access Token** | 访问令牌,用于访问用户资源 |
| **Redirect URI** | 授权后的回调地址,必须与注册时一致 |
| **Scope** | 权限范围,定义应用可以访问的资源 |

## 3. 支持的OAuth提供商

### 3.1 GitHub OAuth

**官方文档**: https://docs.github.com/en/developers/apps/building-oauth-apps

**特点**:
- 面向开发者用户,技术社区认可度高
- 无需审核,注册即可使用
- 免费且稳定
- 提供丰富的用户信息(邮箱、头像、bio等)

**应用注册流程**:
1. 访问 https://github.com/settings/developers
2. 点击"New OAuth App"
3. 填写应用信息:
   - Application name: `3D生成打印平台`
   - Homepage URL: `http://localhost:5173`
   - Authorization callback URL: `http://localhost:3000/auth/github/callback`
4. 获取Client ID和Client Secret

**可用的用户信息**:
```json
{
  "id": 123456,
  "login": "username",
  "name": "User Name",
  "email": "user@example.com",
  "avatar_url": "https://avatars.githubusercontent.com/u/123456",
  "bio": "Developer",
  "location": "Beijing, China",
  "created_at": "2015-01-01T00:00:00Z"
}
```

**推荐指数**: ⭐⭐⭐⭐⭐ (5/5)

---

### 3.2 Google OAuth

**官方文档**: https://developers.google.com/identity/protocols/oauth2

**特点**:
- 用户基数最大
- 全球通用,覆盖面广
- 提供详细的用户资料
- 支持多种授权模式

**应用注册流程**:
1. 访问 https://console.cloud.google.com/
2. 创建新项目或选择现有项目
3. 启用Google+ API
4. 创建OAuth 2.0客户端ID:
   - 应用类型: Web应用
   - 授权的重定向URI: `http://localhost:3000/auth/google/callback`
5. 获取客户端ID和客户端密钥

**可用的用户信息**:
```json
{
  "id": "1234567890",
  "email": "user@gmail.com",
  "verified_email": true,
  "name": "User Name",
  "given_name": "User",
  "family_name": "Name",
  "picture": "https://lh3.googleusercontent.com/...",
  "locale": "zh-CN"
}
```

**推荐指数**: ⭐⭐⭐⭐⭐ (5/5)

---

### 3.3 微信开放平台

**官方文档**: https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html

**特点**:
- 国内用户基数最大
- 移动端体验最佳
- 需要企业认证(300元/年)
- 审核周期约7个工作日

**应用注册流程**:
1. 注册微信开放平台账号 https://open.weixin.qq.com/
2. 完成开发者资质认证(需企业资质)
3. 创建网站应用
4. 填写应用资料并等待审核
5. 审核通过后获取AppID和AppSecret

**可用的用户信息**:
```json
{
  "openid": "oMgHVjngRipVsoxg6TuX",
  "nickname": "用户昵称",
  "sex": 1,
  "language": "zh_CN",
  "city": "北京",
  "province": "北京",
  "country": "中国",
  "headimgurl": "http://thirdwx.qlogo.cn/..."
}
```

**注意事项**:
- ⚠️ 需要企业资质认证
- ⚠️ 需要备案域名
- ⚠️ 不适合个人开发者

**推荐指数**: ⭐⭐⭐ (3/5) - 仅适合企业用户

---

### 3.4 支付宝授权登录

**官方文档**: https://opendocs.alipay.com/open/263/105808

**特点**:
- 用户实名认证
- 支付场景天然集成
- 需要企业认证
- 提供实名信息接口

**应用注册流程**:
1. 注册支付宝开放平台账号 https://open.alipay.com/
2. 创建网页/移动应用
3. 配置应用信息和回调地址
4. 上传企业资质并等待审核
5. 获取AppID

**可用的用户信息**:
```json
{
  "user_id": "2088102146225135",
  "avatar": "https://tfs.alipayobjects.com/...",
  "province": "浙江省",
  "city": "杭州市",
  "nick_name": "用户昵称",
  "is_student": false,
  "user_type": "1",
  "user_status": "T",
  "is_certified": true
}
```

**推荐指数**: ⭐⭐⭐ (3/5) - 适合有支付需求的应用

---

### 3.5 QQ互联

**官方文档**: https://wiki.connect.qq.com/

**特点**:
- QQ用户基数大
- 个人开发者可申请
- 审核相对宽松
- 移动端集成便捷

**应用注册流程**:
1. 注册QQ互联账号 https://connect.qq.com/
2. 创建网站应用
3. 填写网站信息和备案号
4. 等待审核(约3-7天)
5. 获取AppID和AppKey

**可用的用户信息**:
```json
{
  "ret": 0,
  "msg": "",
  "nickname": "用户昵称",
  "figureurl_qq_1": "http://q.qlogo.cn/...",
  "gender": "男",
  "province": "北京",
  "city": "海淀"
}
```

**推荐指数**: ⭐⭐⭐⭐ (4/5)

---

## 4. 技术实现方案

### 4.1 后端实现(Node.js + Express)

#### 4.1.1 项目结构

```
backend/
├── src/
│   ├── config/
│   │   └── oauth.ts          # OAuth配置
│   ├── controllers/
│   │   └── auth.controller.ts # 认证控制器
│   ├── services/
│   │   ├── auth.service.ts    # 认证服务
│   │   └── oauth.service.ts   # OAuth服务
│   ├── models/
│   │   └── user.model.ts      # 用户模型
│   ├── routes/
│   │   └── auth.routes.ts     # 认证路由
│   └── middleware/
│       └── auth.middleware.ts # 认证中间件
└── package.json
```

#### 4.1.2 OAuth配置文件

```typescript
// src/config/oauth.ts
export interface OAuthConfig {
  clientId: string
  clientSecret: string
  redirectUri: string
  authorizationUrl: string
  tokenUrl: string
  userInfoUrl: string
  scope: string[]
}

export const oauthProviders: Record<string, OAuthConfig> = {
  github: {
    clientId: process.env.GITHUB_CLIENT_ID!,
    clientSecret: process.env.GITHUB_CLIENT_SECRET!,
    redirectUri: `${process.env.API_BASE_URL}/auth/github/callback`,
    authorizationUrl: 'https://github.com/login/oauth/authorize',
    tokenUrl: 'https://github.com/login/oauth/access_token',
    userInfoUrl: 'https://api.github.com/user',
    scope: ['read:user', 'user:email']
  },
  
  google: {
    clientId: process.env.GOOGLE_CLIENT_ID!,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    redirectUri: `${process.env.API_BASE_URL}/auth/google/callback`,
    authorizationUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenUrl: 'https://oauth2.googleapis.com/token',
    userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
    scope: [
      'https://www.googleapis.com/auth/userinfo.email',
      'https://www.googleapis.com/auth/userinfo.profile'
    ]
  }
}
```

#### 4.1.3 OAuth服务实现

```typescript
// src/services/oauth.service.ts
import axios from 'axios'
import { oauthProviders, OAuthConfig } from '../config/oauth'

export interface OAuthUser {
  providerId: string
  provider: string
  email: string
  name: string
  avatar?: string
  rawData: any
}

export class OAuthService {
  private config: OAuthConfig

  constructor(private provider: string) {
    this.config = oauthProviders[provider]
    if (!this.config) {
      throw new Error(`不支持的OAuth提供商: ${provider}`)
    }
  }

  /**
   * 生成授权URL
   */
  getAuthorizationUrl(state: string): string {
    const params = new URLSearchParams({
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUri,
      scope: this.config.scope.join(' '),
      state,
      response_type: 'code'
    })

    return `${this.config.authorizationUrl}?${params.toString()}`
  }

  /**
   * 使用授权码换取access_token
   */
  async getAccessToken(code: string): Promise<string> {
    try {
      const response = await axios.post(
        this.config.tokenUrl,
        {
          client_id: this.config.clientId,
          client_secret: this.config.clientSecret,
          code,
          redirect_uri: this.config.redirectUri,
          grant_type: 'authorization_code'
        },
        {
          headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json'
          }
        }
      )

      return response.data.access_token
    } catch (error) {
      console.error('获取access_token失败:', error)
      throw new Error('OAuth授权失败')
    }
  }

  /**
   * 使用access_token获取用户信息
   */
  async getUserInfo(accessToken: string): Promise<OAuthUser> {
    try {
      const response = await axios.get(this.config.userInfoUrl, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: 'application/json'
        }
      })

      return this.normalizeUserInfo(response.data)
    } catch (error) {
      console.error('获取用户信息失败:', error)
      throw new Error('获取用户信息失败')
    }
  }

  /**
   * 标准化不同提供商的用户信息
   */
  private normalizeUserInfo(rawData: any): OAuthUser {
    switch (this.provider) {
      case 'github':
        return {
          providerId: String(rawData.id),
          provider: 'github',
          email: rawData.email,
          name: rawData.name || rawData.login,
          avatar: rawData.avatar_url,
          rawData
        }

      case 'google':
        return {
          providerId: rawData.id,
          provider: 'google',
          email: rawData.email,
          name: rawData.name,
          avatar: rawData.picture,
          rawData
        }

      default:
        throw new Error(`不支持的提供商: ${this.provider}`)
    }
  }
}
```

#### 4.1.4 认证控制器

```typescript
// src/controllers/auth.controller.ts
import { Request, Response } from 'express'
import crypto from 'crypto'
import jwt from 'jsonwebtoken'
import { OAuthService } from '../services/oauth.service'
import { User } from '../models/user.model'

// 存储state,用于CSRF防护(生产环境应使用Redis)
const stateStore = new Map<string, { timestamp: number }>()

export class AuthController {
  /**
   * 发起OAuth授权
   */
  async initiateOAuth(req: Request, res: Response) {
    try {
      const { provider } = req.params
      const oauthService = new OAuthService(provider)

      // 生成随机state用于CSRF防护
      const state = crypto.randomBytes(16).toString('hex')
      stateStore.set(state, { timestamp: Date.now() })

      // 清理过期的state(超过10分钟)
      const now = Date.now()
      for (const [key, value] of stateStore.entries()) {
        if (now - value.timestamp > 10 * 60 * 1000) {
          stateStore.delete(key)
        }
      }

      const authUrl = oauthService.getAuthorizationUrl(state)
      res.redirect(authUrl)
    } catch (error) {
      console.error('OAuth授权失败:', error)
      res.status(500).json({ error: '授权失败' })
    }
  }

  /**
   * 处理OAuth回调
   */
  async handleOAuthCallback(req: Request, res: Response) {
    try {
      const { provider } = req.params
      const { code, state } = req.query

      // 验证state
      if (!state || !stateStore.has(state as string)) {
        return res.status(400).json({ error: '无效的state参数' })
      }
      stateStore.delete(state as string)

      // 验证code
      if (!code) {
        return res.status(400).json({ error: '缺少授权码' })
      }

      const oauthService = new OAuthService(provider)

      // 换取access_token
      const accessToken = await oauthService.getAccessToken(code as string)

      // 获取用户信息
      const oauthUser = await oauthService.getUserInfo(accessToken)

      // 在数据库中查找或创建用户
      let user = await User.findOne({
        provider: oauthUser.provider,
        providerId: oauthUser.providerId
      })

      if (!user) {
        user = await User.create({
          provider: oauthUser.provider,
          providerId: oauthUser.providerId,
          email: oauthUser.email,
          name: oauthUser.name,
          avatar: oauthUser.avatar,
          oauthData: oauthUser.rawData
        })
      } else {
        // 更新用户信息
        user.name = oauthUser.name
        user.avatar = oauthUser.avatar
        user.lastLoginAt = new Date()
        await user.save()
      }

      // 生成JWT令牌
      const token = jwt.sign(
        {
          userId: user._id,
          email: user.email,
          provider: user.provider
        },
        process.env.JWT_SECRET!,
        { expiresIn: '7d' }
      )

      // 重定向回前端并传递token
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173'
      res.redirect(`${frontendUrl}/auth/callback?token=${token}`)
    } catch (error) {
      console.error('OAuth回调处理失败:', error)
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173'
      res.redirect(`${frontendUrl}/auth/callback?error=授权失败`)
    }
  }

  /**
   * 获取当前用户信息
   */
  async getCurrentUser(req: Request, res: Response) {
    try {
      const userId = (req as any).user.userId
      const user = await User.findById(userId).select('-oauthData')

      if (!user) {
        return res.status(404).json({ error: '用户不存在' })
      }

      res.json({
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          avatar: user.avatar,
          provider: user.provider,
          createdAt: user.createdAt
        }
      })
    } catch (error) {
      console.error('获取用户信息失败:', error)
      res.status(500).json({ error: '获取用户信息失败' })
    }
  }
}
```

#### 4.1.5 用户模型

```typescript
// src/models/user.model.ts
import mongoose, { Document, Schema } from 'mongoose'

export interface IUser extends Document {
  provider: string
  providerId: string
  email: string
  name: string
  avatar?: string
  oauthData?: any
  createdAt: Date
  lastLoginAt?: Date
}

const userSchema = new Schema<IUser>({
  provider: {
    type: String,
    required: true,
    enum: ['github', 'google', 'wechat', 'alipay', 'qq']
  },
  providerId: {
    type: String,
    required: true
  },
  email: {
    type: String,
    required: true
  },
  name: {
    type: String,
    required: true
  },
  avatar: {
    type: String
  },
  oauthData: {
    type: Schema.Types.Mixed
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  lastLoginAt: {
    type: Date
  }
})

// 复合唯一索引
userSchema.index({ provider: 1, providerId: 1 }, { unique: true })

export const User = mongoose.model<IUser>('User', userSchema)
```

#### 4.1.6 路由配置

```typescript
// src/routes/auth.routes.ts
import { Router } from 'express'
import { AuthController } from '../controllers/auth.controller'
import { authMiddleware } from '../middleware/auth.middleware'

const router = Router()
const authController = new AuthController()

// OAuth登录路由
router.get('/auth/:provider', (req, res) => 
  authController.initiateOAuth(req, res)
)

// OAuth回调路由
router.get('/auth/:provider/callback', (req, res) => 
  authController.handleOAuthCallback(req, res)
)

// 获取当前用户信息(需要认证)
router.get('/auth/me', authMiddleware, (req, res) => 
  authController.getCurrentUser(req, res)
)

export default router
```

#### 4.1.7 认证中间件

```typescript
// src/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express'
import jwt from 'jsonwebtoken'

export const authMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.headers.authorization?.split(' ')[1]

    if (!token) {
      return res.status(401).json({ error: '未提供认证令牌' })
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!)
    ;(req as any).user = decoded
    next()
  } catch (error) {
    console.error('令牌验证失败:', error)
    res.status(401).json({ error: '无效的认证令牌' })
  }
}
```

### 4.2 前端实现(Vue3 + TypeScript)

#### 4.2.1 项目结构

```
frontend/
├── src/
│   ├── stores/
│   │   └── auth.ts           # 认证Store
│   ├── services/
│   │   └── auth.service.ts   # 认证服务
│   ├── router/
│   │   ├── index.ts          # 路由配置
│   │   └── guards.ts         # 路由守卫
│   ├── views/
│   │   ├── Login.vue         # 登录页面
│   │   └── AuthCallback.vue  # OAuth回调页面
│   ├── components/
│   │   └── OAuthButtons.vue  # OAuth登录按钮
│   └── types/
│       └── auth.ts           # 类型定义
└── package.json
```

#### 4.2.2 类型定义

```typescript
// src/types/auth.ts
export interface User {
  id: string
  email: string
  name: string
  avatar?: string
  provider: string
  createdAt: string
}

export interface AuthState {
  user: User | null
  token: string | null
  loading: boolean
  error: string | null
}

export type OAuthProvider = 'github' | 'google' | 'wechat' | 'alipay' | 'qq'
```

#### 4.2.3 认证Store

```typescript
// src/stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { User, OAuthProvider } from '@/types/auth'
import { authService } from '@/services/auth.service'

export const useAuthStore = defineStore('auth', () => {
  // 状态
  const user = ref<User | null>(null)
  const token = ref<string | null>(localStorage.getItem('token'))
  const loading = ref(false)
  const error = ref<string | null>(null)

  // 计算属性
  const isAuthenticated = computed(() => !!user.value && !!token.value)

  // 方法
  const loginWithOAuth = (provider: OAuthProvider) => {
    const apiBaseUrl = import.meta.env.VITE_API_BASE_URL
    window.location.href = `${apiBaseUrl}/auth/${provider}`
  }

  const setToken = (newToken: string) => {
    token.value = newToken
    localStorage.setItem('token', newToken)
    
    // 设置axios默认header
    authService.setAuthHeader(newToken)
  }

  const setUser = (newUser: User) => {
    user.value = newUser
  }

  const logout = () => {
    user.value = null
    token.value = null
    localStorage.removeItem('token')
    authService.removeAuthHeader()
  }

  const fetchUser = async () => {
    if (!token.value) {
      return
    }

    loading.value = true
    error.value = null

    try {
      const response = await authService.getCurrentUser()
      user.value = response.user
    } catch (e: any) {
      console.error('获取用户信息失败:', e)
      error.value = e.message
      logout()
    } finally {
      loading.value = false
    }
  }

  // 初始化时恢复认证状态
  const init = async () => {
    if (token.value) {
      authService.setAuthHeader(token.value)
      await fetchUser()
    }
  }

  return {
    // 状态
    user,
    token,
    loading,
    error,
    // 计算属性
    isAuthenticated,
    // 方法
    loginWithOAuth,
    setToken,
    setUser,
    logout,
    fetchUser,
    init
  }
})
```

#### 4.2.4 认证服务

```typescript
// src/services/auth.service.ts
import axios from 'axios'
import type { User } from '@/types/auth'

const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL
})

class AuthService {
  setAuthHeader(token: string) {
    api.defaults.headers.common['Authorization'] = `Bearer ${token}`
  }

  removeAuthHeader() {
    delete api.defaults.headers.common['Authorization']
  }

  async getCurrentUser(): Promise<{ user: User }> {
    const response = await api.get('/auth/me')
    return response.data
  }
}

export const authService = new AuthService()
export default api
```

#### 4.2.5 OAuth回调页面

```vue
<!-- src/views/AuthCallback.vue -->
<template>
  <div class="min-h-screen flex items-center justify-center bg-gray-50">
    <div class="text-center">
      <div v-if="loading" class="space-y-4">
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
        <p class="text-gray-600">正在登录...</p>
      </div>

      <div v-else-if="error" class="space-y-4">
        <div class="text-red-600">
          <svg class="h-12 w-12 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </div>
        <h2 class="text-xl font-semibold text-gray-900">登录失败</h2>
        <p class="text-gray-600">{{ error }}</p>
        <button 
          @click="router.push('/login')"
          class="mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
        >
          返回登录页
        </button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const route = useRoute()
const router = useRouter()
const authStore = useAuthStore()

const loading = ref(true)
const error = ref('')

onMounted(async () => {
  const token = route.query.token as string
  const errorMsg = route.query.error as string

  if (errorMsg) {
    error.value = errorMsg
    loading.value = false
    return
  }

  if (!token) {
    error.value = '未收到认证令牌'
    loading.value = false
    return
  }

  try {
    authStore.setToken(token)
    await authStore.fetchUser()

    // 登录成功,跳转到首页或原来想访问的页面
    const redirect = route.query.redirect as string
    router.push(redirect || '/')
  } catch (e: any) {
    error.value = e.message || '登录过程中发生错误'
  } finally {
    loading.value = false
  }
})
</script>
```

#### 4.2.6 OAuth登录按钮组件

```vue
<!-- src/components/OAuthButtons.vue -->
<template>
  <div class="space-y-3">
    <button 
      v-for="provider in providers"
      :key="provider.name"
      @click="handleLogin(provider.name)"
      :disabled="loading"
      class="w-full flex items-center justify-center gap-3 px-4 py-3 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
    >
      <img 
        :src="provider.icon" 
        :alt="provider.label"
        class="w-5 h-5"
      />
      <span class="font-medium text-gray-700">
        使用 {{ provider.label }} 登录
      </span>
    </button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useAuthStore } from '@/stores/auth'
import type { OAuthProvider } from '@/types/auth'

interface Provider {
  name: OAuthProvider
  label: string
  icon: string
}

const authStore = useAuthStore()
const loading = ref(false)

const providers: Provider[] = [
  {
    name: 'github',
    label: 'GitHub',
    icon: '/icons/github.svg'
  },
  {
    name: 'google',
    label: 'Google',
    icon: '/icons/google.svg'
  }
]

const handleLogin = (provider: OAuthProvider) => {
  loading.value = true
  authStore.loginWithOAuth(provider)
}
</script>
```

#### 4.2.7 登录页面

```vue
<!-- src/views/Login.vue -->
<template>
  <div class="min-h-screen flex items-center justify-center bg-gray-50 px-4">
    <div class="max-w-md w-full">
      <div class="text-center mb-8">
        <h1 class="text-3xl font-bold text-gray-900">3D生成打印平台</h1>
        <p class="mt-2 text-gray-600">选择一种方式登录</p>
      </div>

      <div class="bg-white rounded-lg shadow-lg p-8">
        <OAuthButtons />
        
        <div class="mt-6 text-center text-sm text-gray-500">
          登录即表示您同意我们的
          <a href="/terms" class="text-blue-600 hover:underline">服务条款</a>
          和
          <a href="/privacy" class="text-blue-600 hover:underline">隐私政策</a>
        </div>
      </div>

      <div class="mt-4 text-center text-sm text-gray-600">
        还没有账号? 通过上述方式登录即可自动创建账号
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import OAuthButtons from '@/components/OAuthButtons.vue'
</script>
```

#### 4.2.8 路由配置

```typescript
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'
import { authGuard } from './guards'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/login',
      name: 'Login',
      component: () => import('@/views/Login.vue'),
      meta: { requiresAuth: false }
    },
    {
      path: '/auth/callback',
      name: 'AuthCallback',
      component: () => import('@/views/AuthCallback.vue'),
      meta: { requiresAuth: false }
    },
    {
      path: '/',
      name: 'Home',
      component: () => import('@/views/Home.vue'),
      meta: { requiresAuth: true }
    },
    {
      path: '/dashboard',
      name: 'Dashboard',
      component: () => import('@/views/Dashboard.vue'),
      meta: { requiresAuth: true }
    }
  ]
})

router.beforeEach(authGuard)

export default router
```

#### 4.2.9 路由守卫

```typescript
// src/router/guards.ts
import type { NavigationGuardNext, RouteLocationNormalized } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

export const authGuard = async (
  to: RouteLocationNormalized,
  from: RouteLocationNormalized,
  next: NavigationGuardNext
) => {
  const authStore = useAuthStore()

  // 初始化认证状态(仅首次)
  if (!authStore.user && authStore.token) {
    await authStore.init()
  }

  // 需要认证的路由
  if (to.meta.requiresAuth) {
    if (!authStore.isAuthenticated) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
      return
    }
  }

  // 已登录用户访问登录页,重定向到首页
  if (to.path === '/login' && authStore.isAuthenticated) {
    next('/')
    return
  }

  next()
}
```

## 5. 安全最佳实践

### 5.1 CSRF防护

使用state参数防止跨站请求伪造攻击:

```typescript
// 生成随机state
const state = crypto.randomBytes(16).toString('hex')

// 存储state(使用Redis在生产环境)
await redis.set(`oauth:state:${state}`, '1', 'EX', 600)

// 验证回调时的state
const storedState = await redis.get(`oauth:state:${state}`)
if (!storedState) {
  throw new Error('Invalid state parameter')
}
await redis.del(`oauth:state:${state}`)
```

### 5.2 令牌安全

```typescript
// JWT令牌最佳实践
const token = jwt.sign(
  {
    userId: user._id,
    email: user.email,
    provider: user.provider,
    // 不要在令牌中存储敏感信息
  },
  process.env.JWT_SECRET!,
  {
    expiresIn: '7d',
    issuer: 'your-app-name',
    audience: 'your-app-users'
  }
)

// 使用HttpOnly Cookie存储令牌(更安全)
res.cookie('token', token, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: 7 * 24 * 60 * 60 * 1000 // 7天
})
```

### 5.3 HTTPS强制

```typescript
// 生产环境强制使用HTTPS
if (process.env.NODE_ENV === 'production') {
  app.use((req, res, next) => {
    if (req.header('x-forwarded-proto') !== 'https') {
      res.redirect(`https://${req.header('host')}${req.url}`)
    } else {
      next()
    }
  })
}
```

### 5.4 Redirect URI验证

```typescript
// 严格验证Redirect URI
const allowedRedirectUris = [
  'http://localhost:3000/auth/github/callback',
  'https://yourdomain.com/auth/github/callback'
]

if (!allowedRedirectUris.includes(redirectUri)) {
  throw new Error('Invalid redirect_uri')
}
```

### 5.5 敏感信息保护

```typescript
// 不要在前端暴露Client Secret
// ❌ 错误示例
const clientSecret = 'your-secret' // 不要在前端代码中

// ✅ 正确示例
// Client Secret只应在后端使用
const response = await axios.post(tokenUrl, {
  client_secret: process.env.GITHUB_CLIENT_SECRET
})
```

## 6. 错误处理

### 6.1 常见错误类型

| 错误 | 原因 | 解决方案 |
|------|------|---------|
| `invalid_client` | Client ID或Secret错误 | 检查环境变量配置 |
| `redirect_uri_mismatch` | 回调地址不匹配 | 确保Redirect URI与OAuth应用配置一致 |
| `access_denied` | 用户拒绝授权 | 提示用户需要授权才能登录 |
| `invalid_grant` | 授权码无效或已使用 | 授权码只能使用一次,请重新授权 |
| `insufficient_scope` | 权限范围不足 | 检查scope配置是否包含所需权限 |

### 6.2 错误处理示例

```typescript
// 前端错误处理
try {
  await authStore.loginWithOAuth('github')
} catch (error) {
  if (error.response?.status === 401) {
    // 认证失败
    showError('登录失败,请重试')
  } else if (error.response?.status === 400) {
    // 参数错误
    showError('请求参数错误')
  } else {
    // 其他错误
    showError('发生未知错误,请联系管理员')
  }
}

// 后端错误处理
try {
  const accessToken = await oauthService.getAccessToken(code)
} catch (error) {
  if (axios.isAxiosError(error)) {
    const status = error.response?.status
    const message = error.response?.data?.error_description
    
    logger.error('OAuth错误:', { status, message, provider })
    
    // 返回友好的错误信息
    throw new OAuthError(
      message || 'OAuth授权失败',
      status || 500
    )
  }
  throw error
}
```

## 7. 性能优化

### 7.1 状态缓存

```typescript
// 使用Redis缓存OAuth state
class StateStore {
  private redis: Redis
  
  async set(state: string, data: any, ttl: number = 600) {
    await this.redis.setex(
      `oauth:state:${state}`,
      ttl,
      JSON.stringify(data)
    )
  }
  
  async get(state: string): Promise<any> {
    const data = await this.redis.get(`oauth:state:${state}`)
    return data ? JSON.parse(data) : null
  }
  
  async delete(state: string) {
    await this.redis.del(`oauth:state:${state}`)
  }
}
```

### 7.2 用户信息缓存

```typescript
// 缓存用户信息减少API调用
const cacheKey = `user:${userId}`
const cachedUser = await redis.get(cacheKey)

if (cachedUser) {
  return JSON.parse(cachedUser)
}

const user = await User.findById(userId)
await redis.setex(cacheKey, 3600, JSON.stringify(user))

return user
```

### 7.3 并发限制

```typescript
// 限制OAuth请求频率
import rateLimit from 'express-rate-limit'

const oauthLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 5, // 最多5次OAuth请求
  message: 'OAuth请求过于频繁,请稍后再试'
})

router.get('/auth/:provider', oauthLimiter, authController.initiateOAuth)
```

## 8. 测试策略

### 8.1 单元测试

```typescript
// 测试OAuth服务
describe('OAuthService', () => {
  describe('getAuthorizationUrl', () => {
    it('should generate valid authorization URL', () => {
      const oauthService = new OAuthService('github')
      const state = 'test-state'
      const url = oauthService.getAuthorizationUrl(state)
      
      expect(url).toContain('github.com/login/oauth/authorize')
      expect(url).toContain(`state=${state}`)
      expect(url).toContain('client_id=')
    })
  })
  
  describe('getUserInfo', () => {
    it('should normalize GitHub user info', async () => {
      const mockData = {
        id: 123456,
        login: 'testuser',
        email: 'test@example.com',
        avatar_url: 'https://avatars.github.com/u/123456'
      }
      
      const oauthService = new OAuthService('github')
      const user = await oauthService.getUserInfo('mock-token')
      
      expect(user.providerId).toBe('123456')
      expect(user.provider).toBe('github')
      expect(user.email).toBe('test@example.com')
    })
  })
})
```

### 8.2 集成测试

```typescript
// 测试完整OAuth流程
describe('OAuth Flow', () => {
  it('should complete GitHub OAuth flow', async () => {
    // 1. 发起授权
    const response1 = await request(app)
      .get('/auth/github')
      .expect(302)
    
    const location = response1.headers.location
    expect(location).toContain('github.com/login/oauth/authorize')
    
    // 2. 模拟回调
    const state = new URL(location).searchParams.get('state')
    const response2 = await request(app)
      .get(`/auth/github/callback?code=test-code&state=${state}`)
      .expect(302)
    
    // 3. 验证token
    const callbackLocation = new URL(response2.headers.location)
    const token = callbackLocation.searchParams.get('token')
    
    expect(token).toBeTruthy()
    
    // 4. 使用token获取用户信息
    const response3 = await request(app)
      .get('/auth/me')
      .set('Authorization', `Bearer ${token}`)
      .expect(200)
    
    expect(response3.body.user.email).toBeTruthy()
  })
})
```

### 8.3 E2E测试

```typescript
// Cypress E2E测试
describe('OAuth Login', () => {
  it('should login with GitHub', () => {
    cy.visit('/login')
    
    // 点击GitHub登录按钮
    cy.contains('使用 GitHub 登录').click()
    
    // 模拟GitHub授权页面
    cy.origin('https://github.com', () => {
      cy.get('[name="authorize"]').click()
    })
    
    // 验证登录成功
    cy.url().should('include', '/')
    cy.get('[data-testid="user-avatar"]').should('be.visible')
  })
})
```

## 9. 监控与日志

### 9.1 关键指标监控

```typescript
// Prometheus指标
import promClient from 'prom-client'

const oauthAttempts = new promClient.Counter({
  name: 'oauth_attempts_total',
  help: 'Total OAuth login attempts',
  labelNames: ['provider', 'status']
})

const oauthDuration = new promClient.Histogram({
  name: 'oauth_duration_seconds',
  help: 'OAuth flow duration',
  labelNames: ['provider']
})

// 记录指标
oauthAttempts.inc({ provider: 'github', status: 'success' })
oauthDuration.observe({ provider: 'github' }, 1.5)
```

### 9.2 结构化日志

```typescript
// Winston日志
import winston from 'winston'

const logger = winston.createLogger({
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'oauth.log' })
  ]
})

// 记录OAuth事件
logger.info('OAuth login initiated', {
  provider: 'github',
  userId: user.id,
  ip: req.ip,
  userAgent: req.headers['user-agent']
})
```

## 10. 部署建议

### 10.1 环境变量配置

```bash
# .env.production
NODE_ENV=production
API_BASE_URL=https://api.yourdomain.com
FRONTEND_URL=https://yourdomain.com

# GitHub OAuth
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret

# Google OAuth
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# JWT
JWT_SECRET=your_very_long_and_random_secret_key

# Database
MONGODB_URI=mongodb://localhost:27017/your_database

# Redis
REDIS_URL=redis://localhost:6379
```

### 10.2 Docker部署

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

ENV NODE_ENV=production
EXPOSE 3000

CMD ["node", "dist/server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongo:27017/app
      - REDIS_URL=redis://redis:6379
    env_file:
      - .env.production
    depends_on:
      - mongo
      - redis

  mongo:
    image: mongo:6
    volumes:
      - mongo-data:/data/db

  redis:
    image: redis:7-alpine
    volumes:
      - redis-data:/data

volumes:
  mongo-data:
  redis-data:
```

### 10.3 HTTPS配置

```typescript
// 使用Let's Encrypt免费证书
import https from 'https'
import fs from 'fs'

const options = {
  key: fs.readFileSync('/etc/letsencrypt/live/yourdomain.com/privkey.pem'),
  cert: fs.readFileSync('/etc/letsencrypt/live/yourdomain.com/fullchain.pem')
}

const server = https.createServer(options, app)
server.listen(443)
```

## 11. 总结与建议

### 11.1 推荐实施方案

**阶段1: 基础OAuth集成(1-2周)**
- ✅ 实现GitHub OAuth登录
- ✅ 实现Google OAuth登录
- ✅ 完成后端API和前端UI
- ✅ 基础错误处理和安全措施

**阶段2: 功能完善(1周)**
- ✅ 添加账号绑定功能
- ✅ 实现邮箱验证
- ✅ 用户资料管理
- ✅ 头像上传

**阶段3: 安全加固(1周)**
- ✅ CSRF防护
- ✅ 速率限制
- ✅ 安全日志
- ✅ 监控告警

### 11.2 技术选型建议

| 组件 | 推荐方案 | 理由 |
|------|---------|------|
| **OAuth提供商** | GitHub + Google | 覆盖开发者和普通用户,无需企业资质 |
| **后端框架** | Express.js | 与Vue3技术栈匹配,生态成熟 |
| **数据库** | MongoDB | 灵活的文档模型,适合用户数据 |
| **缓存** | Redis | 高性能,支持分布式 |
| **令牌** | JWT | 无状态,易于扩展 |

### 11.3 成本估算

**开发成本**:
- 后端开发: 2周 (1人)
- 前端开发: 1.5周 (1人)
- 测试调试: 0.5周
- **总计**: 约4周

**运营成本**:
- 服务器: $10-50/月
- 域名: $10/年
- SSL证书: 免费(Let's Encrypt)
- OAuth服务: 免费
- **月成本**: $10-50

### 11.4 风险与对策

| 风险 | 影响 | 概率 | 对策 |
|------|------|------|------|
| OAuth提供商服务中断 | 高 | 低 | 实现多个OAuth提供商,用户可选择 |
| Token泄露 | 高 | 中 | 使用短期token,定期轮换secret |
| CSRF攻击 | 高 | 中 | 实现state验证和CSRF token |
| 用户账号被盗 | 中 | 低 | 记录登录历史,异常提醒 |

## 12. 参考资源

### 12.1 官方文档
- [OAuth 2.0 RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)
- [GitHub OAuth Apps](https://docs.github.com/en/developers/apps/building-oauth-apps)
- [Google OAuth 2.0](https://developers.google.com/identity/protocols/oauth2)
- [微信开放平台](https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html)

### 12.2 安全指南
- [OWASP OAuth 2.0 Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth_2_0_Cheat_Sheet.html)
- [JWT Best Practices](https://datatracker.ietf.org/doc/html/rfc8725)

### 12.3 开源项目
- [Passport.js](https://www.passportjs.org/) - Node.js认证中间件
- [NextAuth.js](https://next-auth.js.org/) - Next.js认证库
- [Supabase Auth](https://github.com/supabase/auth) - 开源认证服务

---

**文档版本**: v2.0  
**创建日期**: 2025-10-25  
**最后更新**: 2025-10-25  
**维护者**: 3D生成打印平台开发团队
